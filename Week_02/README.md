# 9 月学习笔记--第二周

### 有效的字母异位词 242

    注意：什么叫做字母异位词：字母个数相同，但是顺序不同。考虑字母大小写，这里假定为小写字母。
    1、暴力：将两个字符串排序后，逐一对比，看是否相同。
    2、采用hash表，创建一个新数组hash-26个字母空间大小，初始化为0，循环遍历一个字符串S与t，下标i依次遍历，s遇到里面的字母就+1，t遇到里面的字母就-1,最后，采用every(),判断里面每一个元素是否为0，全为0则返回true。

### 字母异位词分组 49

    注意：它不区分排序顺序，考虑小写字母。
    采用hash表映射，定义一个hash表map={};在字符串数组中找单个字符串，首先，先找到代表单个字符串的关键字key；
    然后判断map里面的关键字是否存在，存在的话，就将单个字符串添加到该map的值里面去，要是不存在，就将该字符串赋值给该map键值里面的值中。
    最后，将map里面的对象值全部返回。

### 丑数 49

    注意：1为丑数，n不超过1690
    采用时间空间复杂度为o(n)的方法，采用动态规划，首先申请一个数组，定义一个结果res[0]=1,定义三个指针值分别为ptr2,ptr3,ptr5 初始化为0，然后循环遍历n，找到最小重复值，找到最小的丑数，在该对应的丑数位置上，判断它是属于*2*3*5哪一类的，然后分别进行if判断，在进行后移操作。

### 二叉树的前序中序遍历

    采用递归法，第一步找到一个递归函数，在函数里面采用递归四步法
    1、递归终止条件
    2、处理当前层逻辑
    3、处理下一层逻辑
    4、清除当前层逻辑

### N 叉树的前序层次性遍历

    采用递归法，第一步找到遍历的函数，在此函数里面找到1、设置递归终止条件2、处理当前层结点3、处理每一层子结点，4、清除当前结点。
    在此函数外面后，然后调用此函数，采用最开始设置好的形参，最后返回结果即可。

### 两数之和

    给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
    采用hash表来写，函数包括两个参数，数组nums,目标值target,定义一个hash表hash= {};
    遍历数组中的每一个值，从下标为0开始，采用target - nums[i]得到的值如果在hash表中存在，则返回当前值索引i和对应的目标索引，
    return [hash[target - nums[i]], i];要是不存在，将当前元素对应的索引以及本身值存放在hash表中。hash[nums[i]] =i;
    结尾可以不用返回值，特殊值不存在的返回undefined.

### 三数之和

    给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
    注意：答案中不可以包含重复的三元组。
    解答这道题时间复杂度低一些的话，采用排序+双指针
    函数的参数有一个数组nums,定义一个结果数组ans，对数组进行排序，一般采用升序nums.sort((a,b) => a-b),在开始遍历数组中的每一个值，
    判断终止条件，如果第一个数大于0，则后面也是大于0的数，最终结果不会为0，程序结束，break.如果元素相同，则跳过此次循环，进行下一次循环
    if(i>0&&nums[i]===nums[i-1]) continue;定义双指针，l=i+1,r=nums.length-1;且在循环while（l<r）里面，进行定义一个
    sum=nums[i]+nums[l]+nums[r],在对sum进行判断是否=0，>0, <0所应该进行的操作。sum=0，则将当前三数放在ans里面，且再进行去重操作，
    while(l<r&&nums[l] ===nums[l+1]) l++;while(l<r && nums[r]===nums[r-1]) r--;然后再开始进行下一次的++，--操作，l++，r--；
    sum<0,则需要大一点的数，向右移动l++,sum>0,则需要小一点的数，向左移动r--.最后返回ans数组。
